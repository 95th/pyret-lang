sugar g-id:
  | (g-id x) => (s-id (s-global x))
end

sugar mk-s-bind:
  | (mk-s-bind name) => (s-bind false name (a-blank))
end

sugar not:
  | (not x) => (s-prim-app "not" [x])
end

sugar boolean?:
  | (boolean? x) => (s-prim-app "isBoolean" [x])
end

sugar s-when:
  | (s-when @l test body blocky) =>
    (fresh [cond]
      (s-let-expr
        [(s-let-bind (mk-s-bind cond) test)]
        (s-if-else [(s-if-branch (not (boolean? cond))
                                 (s-prim-app "throwNonBooleanWhen"
                                             [(s-srcloc l)
                                              (s-srcloc (meta get-loc-of test))
                                              cond]))
                    (s-if-branch cond (s-block [body (g-id "nothing")]))]
                   (g-id "nothing")
                   blocky)))
end

################################################################################

sugar no-branch-exn:
  | (no-branch-exn @l typ) => (s-prim-app "throwNoBranchesMatched" [(s-srcloc l) (s-str typ)])
end

sugar s-if:
  | (s-if branches blocky) => (s-if-else branches (no-branch-exn "if") blocky)
end

sugar s-if-pipe:
  | (s-if-pipe branches blocky) => (s-if-else branches (no-branch-exn "ask") blocky)
end

sugar s-if-pipe-else:
  | (s-if-pipe-else branches _else blocky) => (s-if-else branches _else blocky)
end

sugar s-if-else:
  | (s-if-else [] _else blocky) => _else
  | (s-if-else [branch rest ...] _else blocky) =>
    <s-if-else [branch] (s-if-else [rest ...] _else blocky) blocky>
end

################################################################################

sugar s-template:
  | (s-template @l) => (s-prim-app "throwUnfinishedTemplate" [(s-srcloc l)])
end

sugar s-user-block:
  | (s-user-block body) => body
end

sugar s-paren:
  | (s-paren body) => body
end

################################################################################

sugar s-import:
  | (s-import file name) => (s-import-complete [] [] file name name)
end
sugar s-import-fields:
  | (s-import-fields fields file) => (s-import-complete fields [] file (s-underscore) (s-underscore))
end

################################################################################

sugar s-underscore:
  | (s-underscore) => {s-underscore}
end

sugar transform-underscore:
  | (transform-underscore {s-underscore}) => (fresh [name] name)
  | (transform-underscore non-underscore) => non-underscore
end

sugar s-import-complete:
  | (s-import-complete vals types import-type vals-name types-name) =>
    <s-import-complete vals
                       types
                       import-type
                       (transform-underscore vals-name)
                       (transform-underscore types-name)>
  # TODO: need another phase before desugaring that goes through vals and types
  # and mark {s-underscore} as invalid
end

sugar s-lam:
  | (s-lam name [param ...] args ann doc body _check-loc _check blocky) =>
    <s-lam name [(transform-underscore param) ...] args ann doc body _check-loc _check blocky>
end

sugar s-bind:
  | (s-bind shadows {s-underscore} ann) => (s-bind shadows (fresh [x] x) ann)
  | (s-bind shadows non-underscore ann) => <s-bind shadows non-underscore ann>
end

################################################################################

sugar s-construct-normal:
  | (s-construct-normal) => {s-construct-normal}
end

sugar s-construct-lazy:
  | (s-construct-lazy) => {s-construct-lazy}
end

sugar s-construct-help:
  | (s-construct-help @l constructor js-name id-name elts) =>
    (s-app @(meta get-loc-of constructor)
           (s-prim-app @(meta get-loc-of constructor)
                       js-name [constructor (s-str id-name) (s-srcloc l)
                                (s-srcloc (meta get-loc-of constructor))])
           elts)
end

sugar s-construct:
  | (s-construct {s-construct-normal} constructor []) =>
    (s-construct-help constructor "getMaker0" "make0" [])
  | (s-construct {s-construct-normal} constructor [e1]) =>
    (s-construct-help constructor "getMaker1" "make1" [e1])
  | (s-construct {s-construct-normal} constructor [e1 e2]) =>
    (s-construct-help constructor "getMaker2" "make2" [e1 e2])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3]) =>
    (s-construct-help constructor "getMaker3" "make3" [e1 e2 e3])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3 e4]) =>
    (s-construct-help constructor "getMaker4" "make4" [e1 e2 e3 e4])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3 e4 e5]) =>
    (s-construct-help constructor "getMaker5" "make5" [e1 e2 e3 e4 e5])
  | (s-construct {s-construct-normal} constructor elts) =>
    (s-construct-help constructor "getMaker" "make" [(s-array elts)])
  | (s-construct {s-construct-lazy} constructor [elt ...]) =>
    (s-construct-help constructor "getLazyMaker" "lazy-make"
      [(s-array [(s-lam "" [] [] (a-blank) "" elt none none false) ...])])
end


################################################################################

sugar check-bool:
  | (check-bool e) => (s-prim-app "checkWrapBoolean" [e])
end

sugar s-op:
  | (s-op op-loc "opor" left right) =>
    (s-if-else [(s-if-branch left (s-bool true))] (check-bool right) false)
  | (s-op op-loc "opand" left right) =>
    (s-if-else [(s-if-branch left (check-bool right))] (s-bool false) false)
  | (s-op op-loc "op^" left right) => (s-app right [left])
  | (s-op op-loc op left right) => (curry-binop [left right] op)
end

sugar s-bracket:
  | (s-bracket @l obj key) =>
    (s-app (s-dot (s-id (s-global "builtins")) "get-value")
           [(s-srcloc l) (s-srcloc (meta get-loc-of obj)) obj key])
  # need to support currying
end

sugar s-method-field:
  | (s-method-field name params args ann doc body _check-loc _check blocky) =>
    (s-data-field name (s-method name params args ann doc body _check-loc _check blocky))
end

sugar s-id:
  | (s-id {s-underscore}) => {s-id-underscore}
  | (s-id id) => <s-id id>
end

sugar curry-acc:
  | (curry-acc [] [param ...] args) =>
    {pair (reverse [(s-bind false param (a-blank)) ...]) (reverse args)}
  | (curry-acc [{s-id-underscore} rest ...] [param ...] [arg ...]) =>
    (fresh [x] (curry-acc [rest ...] [x param ...] [x arg ...]))
  | (curry-acc [e rest ...] [param ...] [arg ...]) =>
    (curry-acc [rest ...] [param ...] [e arg ...])
end

sugar reverse:
  | (reverse args) => (reverse-acc args [])
end

sugar reverse-acc:
  | (reverse-acc [] acc) => acc
  | (reverse-acc [x xs ...] [acc ...]) => (reverse-acc [xs ...] [x acc ...])
end

sugar curry-args:
  | (curry-args lst) => (curry-acc lst [] [])
end

sugar curry-binop:
  | (curry-binop args op) => (curry-binop-help (curry-args args) op)
end

sugar curry-binop-help:
  | (curry-binop-help {pair [] args} "op+") => (s-app (s-id (s-global "_plus")) args)
  | (curry-binop-help {pair [] args} "op-") => (s-app (s-id (s-global "_minus")) args)
  | (curry-binop-help {pair [] args} "op*") => (s-app (s-id (s-global "_times")) args)
  | (curry-binop-help {pair [] args} "op/") => (s-app (s-id (s-global "_divide")) args)
  | (curry-binop-help {pair [] args} "op<") => (s-app (s-id (s-global "_lessthan")) args)
  | (curry-binop-help {pair [] args} "op>") => (s-app (s-id (s-global "_greaterthan")) args)
  | (curry-binop-help {pair [] args} "op>=") => (s-app (s-id (s-global "_greaterequal")) args)
  | (curry-binop-help {pair [] args} "op<=") => (s-app (s-id (s-global "_lessequal")) args)
  | (curry-binop-help {pair [] args} "op==") => (s-app (s-id (s-global "equal-always")) args)
  | (curry-binop-help {pair [] args} "op=~") => (s-app (s-id (s-global "equal-now")) args)
  | (curry-binop-help {pair [] args} "op<=>") => (s-app (s-id (s-global "identical")) args)
  | (curry-binop-help {pair [] args} "op<>") =>
    (s-prim-app "not" [(curry-binop-help {pair [] args} "op==")])
  | (curry-binop-help {pair params args} op) =>
    (s-lam "" [] params (a-blank) "" (curry-binop-help {pair [] args} op) none none false)
end
