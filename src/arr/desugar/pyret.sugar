
sugar s-when:
  | (s-when test body blocky) =>
    (s-if-else [(s-if-branch test (s-block [body (s-id (s-global "nothing"))]))]
               (s-id (s-global "nothing"))
               blocky)
 # 1. need to rewrite (s-id (s-global "nothing")) to use proper var, but this
 # will do it for now

 # 2. this is kinda unpleasant. We cannot inspect that body is s-block or not
 # via pattern matching because of inside-out which makes s-block becomes core
 # which is not matchable
end

sugar no-branch-exn:
  | (no-branch-exn typ) =>
    (s-prim-app "throwNoBranchesMatched" [(s-srcloc (meta get-loc)) (s-str typ)])
end

sugar s-if:
  | (s-if branches blocky) =>
    (s-if-else branches (s-block [(no-branch-exn "if")]) blocky)
  # why do we need s-block wrapped around?
end

sugar s-if-pipe:
  | (s-if-pipe branches blocky) =>
    (s-if-else branches (s-block [(no-branch-exn "ask")]) blocky)
  # why do we need s-block wrapped around?
end

sugar s-if-pipe-else:
  | (s-if-pipe-else branches _else blocky) => (s-if-else branches _else blocky)
end

sugar s-template:
  | (s-template) => (s-prim-app "throwUnfinishedTemplate" [(s-srcloc (meta get-loc))])
end

sugar s-user-block:
  | (s-user-block body) => body
end

sugar s-paren:
  | (s-paren body) => body
end

################################################################################

sugar s-underscore:
  | (s-underscore) => {underscore}
end

################################################################################

sugar s-import:
  | (s-import file name) => (s-import-complete [] [] file name name)
end

sugar s-import-fields:
  | (s-import-fields fields file) => (s-import-complete fields [] file (s-underscore) (s-underscore))
end

sugar transform-underscore:
  | (transform-underscore {underscore}) => (fresh [name] name)
  | (transform-underscore non-underscore) => non-underscore
end

sugar s-import-complete:
  | (s-import-complete [val ...] [type ...] import-type vals-name types-name) =>
    <s-import-complete [(transform-underscore val) ...]
                       [(transform-underscore type) ...]
                       import-type
                       (transform-underscore vals-name)
                       (transform-underscore types-name)>
end

################################################################################

sugar s-construct-normal:
  | (s-construct-normal) => {s-construct-normal}
end

sugar s-construct-lazy:
  | (s-construct-lazy) => {s-construct-lazy}
end

sugar s-construct-help:
  | (s-construct-help constructor js-name id-name elts) =>
    (s-app (s-prim-app js-name [constructor (s-str id-name)
                                (s-srcloc (meta get-loc))
                                (s-srcloc (meta get-loc-of constructor))])
           elts)
end

sugar s-construct:
  | (s-construct {s-construct-normal} constructor []) =>
    (s-construct-help constructor "getMaker0" "make0" [])
  | (s-construct {s-construct-normal} constructor [e1]) =>
    (s-construct-help constructor "getMaker1" "make1" [e1])
  | (s-construct {s-construct-normal} constructor [e1 e2]) =>
    (s-construct-help constructor "getMaker2" "make2" [e1 e2])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3]) =>
    (s-construct-help constructor "getMaker3" "make3" [e1 e2 e3])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3 e4]) =>
    (s-construct-help constructor "getMaker4" "make4" [e1 e2 e3 e4])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3 e4 e5]) =>
    (s-construct-help constructor "getMaker5" "make5" [e1 e2 e3 e4 e5])
  | (s-construct {s-construct-normal} constructor elts) =>
    (s-construct-help constructor "getMaker" "make" [(s-array elts)])
  | (s-construct {s-construct-lazy} constructor [elt ...]) =>
    (s-construct-help constructor "getLazyMaker" "lazy-make"
      [(s-array [(s-lam "" [] [] (a-blank) "" elt none none false) ...])])
  # used srcloc are completely wrong due to the lack of the syntax to put srcloc
  # in the constructing node
end


################################################################################

sugar check-bool:
  | (check-bool e) => (s-prim-app "checkWrapBoolean" [e])
end

sugar s-op:
  | (s-op op-loc "op+" left right) => (s-app (s-id (s-global "_plus")) [left right])
  | (s-op op-loc "op-" left right) => (s-app (s-id (s-global "_minus")) [left right])
  | (s-op op-loc "op*" left right) => (s-app (s-id (s-global "_times")) [left right])
  | (s-op op-loc "op/" left right) => (s-app (s-id (s-global "_divide")) [left right])
  | (s-op op-loc "op<" left right) => (s-app (s-id (s-global "_lessthan")) [left right])
  | (s-op op-loc "op>" left right) => (s-app (s-id (s-global "_greaterthan")) [left right])
  | (s-op op-loc "op>=" left right) => (s-app (s-id (s-global "_greaterequal")) [left right])
  | (s-op op-loc "op<=" left right) => (s-app (s-id (s-global "_lessequal")) [left right])
  | (s-op op-loc "op==" left right) => (s-app (s-id (s-global "equal-always")) [left right])
  | (s-op op-loc "op=~" left right) => (s-app (s-id (s-global "equal-now")) [left right])
  | (s-op op-loc "op<=>" left right) => (s-app (s-id (s-global "identical")) [left right])
  | (s-op op-loc "op<>" left right) => (s-prim-app "not" [(s-op op-loc "op==" left right)])
  | (s-op op-loc "opor" left right) =>
    (s-if-else [(s-if-branch left (s-bool true))] (check-bool right) false)
  | (s-op op-loc "opand" left right) =>
    (s-if-else [(s-if-branch left (check-bool right))] (s-bool false) false)
  | (s-op op-loc "op^" left right) => (s-app right [left])

  # all of these need to support currying (e.g., `_ + _`)
end
