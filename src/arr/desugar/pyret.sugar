sugar g-id:
  | (g-id x) => (s-id (s-global x))
end

sugar b-id:
  | (b-id x) => (s-dot (g-id "builtins") x)
end

sugar s-method-app:
  | (s-method-app l2 obj field args) => (s-app (s-dot @l2 obj field) args)
end

sugar check-ann:
  | (check-ann expr ann) =>
    (fresh [x] (s-let-expr [(s-let-bind (s-bind false x ann) expr)] (s-id x) true))
end

sugar mk-s-bind:
  | (mk-s-bind name) => (s-bind false name (a-blank))
end

sugar mk-s-lam:
  | (mk-s-lam params body) =>
    (s-lam "" [] params (a-blank) "" body none none false)
end

sugar not:
  | (not x) => (s-prim-app "not" [x])
end

sugar boolean?:
  | (boolean? x) => (s-prim-app "isBoolean" [x])
end

################################################################################
# DONE: s-when
################################################################################

sugar s-when:
  | (s-when @l test body blocky) =>
    (fresh [cond]
      (s-let-expr
        [(s-let-bind (mk-s-bind cond) test)]
        (s-if-else [(s-if-branch (not (boolean? (s-id cond)))
                                 (s-prim-app "throwNonBooleanWhen"
                                             [(s-srcloc l)
                                              (s-srcloc (meta get-loc-of test))
                                              (s-id cond)]))
                    (s-if-branch (s-id cond) (s-block [body (g-id "nothing")]))]
                   (g-id "nothing")
                   blocky)
        false))
end

################################################################################
# DONE: s-bracket
################################################################################

sugar s-bracket:
  | (s-bracket @l obj key) =>
    (s-app (b-id "get-value") [(s-srcloc l) (s-srcloc (meta get-loc-of obj)) obj key])
end

################################################################################
# DONE (kind of): s-reactor
################################################################################

sugar s-reactor-field:
  | (s-reactor-field @l name value) => {s-reactor-field l name value}
end

sugar s-reactor:
  | (s-reactor [{s-reactor-field l_{i} name_{i} value_{i}} ...i]) =>
    (reactor-acc [{pair "last-image"       "Function"}
                  {pair "on-tick"          "Function"}
                  {pair "to-draw"          "Function"}
                  {pair "on-key"           "Function"}
                  {pair "on-mouse"         "Function"}
                  {pair "stop-when"        "Function"}
                  {pair "seconds-per-tick" "NumPositive"}
                  {pair "title"            "String"}
                  {pair "close-when-stop"  "Boolean"}]
                 [{s-reactor-field l_{i} name_{i} value_{i}} ...i]
                 (reactor-search {pair "init" "Any"}
                                 [{s-reactor-field l_{i} name_{i} value_{i}} ...i]))
  # when we use this system for well-formedness checking, include:
  # (meta check-dup [name_{i} ...i]) -- this meta produces a wf-error
  # we can use meta because if wf-error happens, then there's no need to resugar
end

sugar reactor-acc:
  | (reactor-acc [to-find_{i} ...i] fields {found l label value check}) =>
    (s-prim-app "makeReactor"
                [value
                 (s-obj [(reactor-map-to-data-field (reactor-search to-find_{i} fields)) ...i])])

  # NOTE: right now we copy `fields` across the map, where `fields` can be arbitrarily large.
  # I think this is fine because the output is not duplicating stuff (disregarding stuff in tags)
  # However, should this become an issue, there are two ways to workaround

  # 1. We can use bijection and implement everything in Pyret. We might need to
  # sacrifice invertibility here

  # 2. We can have 11 arguments, each for last-image, on-tick, etc. And put the
  # handlers into an appropriate argument box. In the end, clean up by replacing
  # all none with Pyret's none (which can be done by adding 11 more cases)
end

sugar reactor-search:
  | (reactor-search {pair label check} [{s-reactor-field l label value} rest_{i} ...i]) =>
    {found l label value check}
  | (reactor-search pair [whatever rest_{i} ...i]) =>
    (reactor-search pair [rest_{i} ...i])
  | (reactor-search @l {pair label check} []) => {not-found l label}
end

sugar reactor-map-to-data-field:
  | (reactor-map-to-data-field {found l label value check}) =>
    (s-data-field @l label
      (s-prim-app @l "makeSome" [(check-ann @l value (a-name @l (s-type-global @l check)))]))
  | (reactor-map-to-data-field {not-found l label}) =>
    (s-data-field @l label (s-prim-app @l "makeNone" []))
end

################################################################################
# DONE: s-if, s-if-else, s-if-pipe, s-if-pipe-else
################################################################################

sugar no-branch-exn:
  | (no-branch-exn @l typ) =>
    (s-prim-app "throwNoBranchesMatched" [(s-srcloc l) (s-str typ)])
end

sugar s-if:
  | (s-if branches blocky) => (s-if-else branches (no-branch-exn "if") blocky)
end

sugar s-if-pipe:
  | (s-if-pipe branches blocky) =>
    (s-if-else branches (no-branch-exn "ask") blocky)
end

sugar s-if-pipe-else:
  | (s-if-pipe-else branches else blocky) => (s-if-else branches else blocky)
end

sugar s-if-else:
  | (s-if-else [] else blocky) => else
  | (s-if-else [branch rest_{x} ...x] else blocky) =>
    <s-if-else [branch] (s-if-else [rest_{x} ...x] else blocky) blocky>
end


################################################################################
# DONE: s-construct
################################################################################

sugar s-construct-normal:
  | (s-construct-normal) => {s-construct-normal}
end

sugar s-construct-lazy:
  | (s-construct-lazy) => {s-construct-lazy}
end

sugar s-construct-help:
  | (s-construct-help @l constructor js-name id-name elts) =>
    (s-app @(meta get-loc-of constructor)
           (s-prim-app @(meta get-loc-of constructor)
                       js-name [constructor (s-str id-name) (s-srcloc l)
                                (s-srcloc (meta get-loc-of constructor))])
           elts)
end

sugar s-construct:
  | (s-construct {s-construct-normal} constructor []) =>
    (s-construct-help constructor "getMaker0" "make0" [])
  | (s-construct {s-construct-normal} constructor [e1]) =>
    (s-construct-help constructor "getMaker1" "make1" [e1])
  | (s-construct {s-construct-normal} constructor [e1 e2]) =>
    (s-construct-help constructor "getMaker2" "make2" [e1 e2])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3]) =>
    (s-construct-help constructor "getMaker3" "make3" [e1 e2 e3])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3 e4]) =>
    (s-construct-help constructor "getMaker4" "make4" [e1 e2 e3 e4])
  | (s-construct {s-construct-normal} constructor [e1 e2 e3 e4 e5]) =>
    (s-construct-help constructor "getMaker5" "make5" [e1 e2 e3 e4 e5])
  | (s-construct {s-construct-normal} constructor elts) =>
    (s-construct-help constructor "getMaker" "make" [(s-array elts)])
  | (s-construct {s-construct-lazy} constructor [elt_{x} ...x]) =>
    (s-construct-help constructor "getLazyMaker" "lazy-make"
      [(s-array [(mk-s-lam [] elt_{x}) ...x])])
end


################################################################################
# DONE: s-template, s-user-block, s-paren
################################################################################

# sugar s-template:
#   | (s-template @l) => (s-prim-app "throwUnfinishedTemplate" [(s-srcloc l)])
# end
#
# sugar s-user-block:
#   | (s-user-block body) => body
# end
#
# sugar s-paren:
#   | (s-paren body) => body
# end

# ################################################################################
# # DONE: s-import, s-import-fields
# ################################################################################
#
# sugar s-import:
#   | (s-import file name) => (s-import-complete [] [] file name name)
# end
# sugar s-import-fields:
#   | (s-import-fields fields file) =>
#     (s-import-complete fields [] file (s-underscore) (s-underscore))
# end
#
# ################################################################################
# # DONE: s-for
# ################################################################################
#
# sugar s-for-bind:
#   | (s-for-bind bind value) => {s-for-bind bind value}
# end
#
# sugar s-for:
#   | (s-for @l iter [{s-for-bind bind_{i} value_{i}} ...i] ann body blocky) =>
#     (s-app
#       iter
#       [(s-lam
#          (meta string-append "<for-body"
#                              (meta string-append (meta srcloc-to-string l) ">"))
#          [] [bind_{i} ...i] ann "" body none none blocky)
#        value_{i} ...i])
# end
#
#
# ################################################################################
# # DONE: s-table
# ################################################################################
#
# sugar s-field-name:
#   | (s-field-name @l name ann) => {s-field-name l name ann}
# end
#
# sugar s-table-row:
#   | (s-table-row elems) => {s-table-row elems}
# end
#
# sugar s-table:
#   | (s-table [{s-field-name l_{i} name_{i} ann_{i}} ...i] [{s-table-row [val_{i j} ...i]} ...j]) =>
#     (s-prim-app "makeTable"
#       [(s-array [(s-str @l_{i} name_{i}) ...i])
#        (s-array [(s-array [(check-ann val_{i j} ann_{i}) ...i]) ...j])])
# end
#
# ################################################################################
# # DONE: s-table-sort
# ################################################################################
#
# sugar s-column-sort:
#   | (s-column-sort @l column direction) => {s-column-sort l column direction}
# end
#
# sugar ASCENDING:
#   | (ASCENDING) => {ASCENDING}
# end
#
# sugar DESCENDING:
#   | (DESCENDING) => {DESCENDING}
# end
#
# sugar s-table-order:
#   | (s-table-order table [{s-column-sort l_{i} column_{i} direction_{i}} ...i]) =>
#     (s-app (s-dot table "multi-order")
#            [(s-array [(table-order-map @l_{i} column_{i} direction_{i}) ...i])])
# end
#
# sugar table-order-map:
#   | (table-order-map column {ASCENDING}) => (s-array [(s-bool true) (s-str (biject name-to-str column))])
#   | (table-order-map column {DESCENDING}) => (s-array [(s-bool false) (s-str (biject name-to-str column))])
# end
#
# ################################################################################
# # DONE: s-load-table
# ################################################################################
#
# sugar s-sanitize:
#   | (s-sanitize name sanitizer) => {s-sanitize name sanitizer}
# end
#
# sugar s-table-src:
#   | (s-table-src src) => {s-table-src src}
# end
#
# sugar load-table-acc:
#   | (load-table-acc [] src sanitizers) => {pair src sanitizers}
#   | (load-table-acc [{s-sanitize name sanitizer} rest_{i} ...i] src [sanitizers_{j} ...j]) =>
#     (load-table-acc [rest_{i} ...i] src
#        [(s-app (b-id "as-loader-option") [(s-str "sanitizer") (s-str (biject name-to-str name)) sanitizer]) sanitizers_{j} ...j])
#   | (load-table-acc [{s-table-src src} rest_{i} ...i] none sanitizers) =>
#     (load-table-acc [rest_{i} ...i] {some src} sanitizers)
#   | (load-table-acc lst {some src} sanitizers) => {WF-ERR-TODO}
# end
#
# sugar s-load-table:
#   | (s-load-table headers spec) => (load-table-helper headers (load-table-acc spec none []))
# end
#
# sugar load-table-helper:
#   | (load-table-helper [{s-field-name l_{i} name_{i} ann_{i}} ...i]
#                        {pair {some src} sanitizers}) =>
#     (s-app (b-id "open-table")
#        [(s-app (s-dot src "load") [(s-array [(s-str name_{i}) ...i])
#                                    (s-array sanitizers)])])
#   | (load-table-helper [header_{i} ...i] {pair none sanitizers}) => {WF-ERR-TODO}
# end
