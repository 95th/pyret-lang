#lang pyret

provide *
provide-types *
import ast as A
import ast-visitors as AV
import parse-pyret as PP
import string-dict as SD
import srcloc as S
import lists as L
import file("compile-structs.arr") as C
import file("ast-util.arr") as U
import file("resolve-scope.arr") as R
import file("../desugar/ds-main.arr") as DNew

names = A.global-names

var generated-binds = SD.make-mutable-string-dict()

fun g(id): A.s-global(id) end
fun gid(l, id): A.s-id(l, g(id)) end
fun bid(l, name): A.s-dot(l, A.s-id(l, g("builtins")), name) end

fun check-table<T>(l, e, cont :: (A.Expr -> T)) -> T:
  cont(A.s-prim-app(l, "checkWrapTable", [list: e]))
end

fun get-table-column(op-l, l, e, column):
  A.s-app(l,
    A.s-dot(A.dummy-loc, e, "_column-index"),
    [list:
      A.s-srcloc(A.dummy-loc, op-l),
      A.s-srcloc(A.dummy-loc, l),
      column.name,
      A.s-srcloc(A.dummy-loc, column.l)])
end

fun check-no-column(op-l, tbl, tbl-l, col, col-l):
  A.s-app(tbl-l,
    A.s-dot(A.dummy-loc, tbl, "_no-column"),
    [list:
      A.s-srcloc(A.dummy-loc, op-l),
      A.s-srcloc(A.dummy-loc, tbl-l),
      A.s-str(A.dummy-loc, col),
      A.s-srcloc(A.dummy-loc, col-l)])
end

fun desugar-expr(e-top :: A.Expr) -> A.Expr:
  e-top.visit(AV.default-map-visitor.{
    # num, den are exact ints, and s-frac desugars to the exact rational num/den
    method s-frac(self, l, num, den):
      A.s-num(l, num / den) # NOTE: Possibly must preserve further?
    end,
    # num, den are exact ints, and s-rfrac desugars to the roughnum fraction corresponding to num/den
    method s-rfrac(self, l, num, den):
      A.s-num(l, num-to-roughnum(num / den)) # NOTE: Possibly must preserve further?
    end,

    method s-table-extend(self, l, column-binds, extensions):
      # NOTE(philip): I am fairly certain that this will need to be moved
      #               to post-type-check desugaring, since the variables used
      #               by reducers is not well-typed
      row = mk-id(A.dummy-loc, "row")
      tbl = mk-id(A.dummy-loc, "table")

      columns =
        column-binds.binds.map(lam(c):
          {name: A.s-str(A.dummy-loc, c.id.base),
           l:  c.l,
           idx:  mk-id(A.dummy-loc, c.id.base),
           val: {id-b: c,
                 id-e: A.s-id(c.l, c.id)}} end)

      reducer-exts = filter(A.is-s-table-extend-reducer, extensions)

      fun mk-reducer-ann(loc, ret-type):
        one = A.a-field(loc, "one", A.a-arrow(loc, [list: A.a-any(loc)], ret-type, true))
        reduce = A.a-field(loc, "reduce",
          A.a-arrow(loc, [list: ret-type, A.a-any(loc)], ret-type, true))
        A.a-record(loc, [list: one, reduce])
      end

      reducer-vars =
        for fold(
            {lef; rig} from {[SD.string-dict:]; [SD.string-dict:]},
            extension from reducer-exts):

          reducer-id = mk-id-ann(A.dummy-loc,
            "reducer" + extension.name,
            mk-reducer-ann(extension.l, extension.ann))

          acc-id = mk-id-var(A.dummy-loc, "acc" + extension.name)

          {lef.set(extension.name, reducer-id); rig.set(extension.name, acc-id)}
        end
      {reducers; accs} = reducer-vars

      initialized-reducers =
        cases(List) reducer-exts:
          | empty => none
          | link(_,_) =>
            some((for fold(reducers-acc from empty, ext from reducer-exts):
                  cases(A.TableExtendField) ext:
                    | s-table-extend-field(_, _, _, _) => raise("Impossible")
                    | s-table-extend-reducer(shadow l, name, reducer-expr, _, _) =>
                      reducer = reducers.get-value(name)
                      acc = accs.get-value(name)
                      nothing-expr = A.s-id(l, A.s-global("nothing"))
                      link(A.s-let-bind(l, reducer.id-b, reducer-expr.visit(self)),
                        link(A.s-var-bind(l, acc.id-b, nothing-expr),
                          reducers-acc))
                  end
                end).reverse())
        end

      with-initialized-reducers =
        cases(Option) initialized-reducers:
          | none => lam(body): body end
          | some(binds) => lam(body): A.s-let-expr(A.dummy-loc, binds, body, true) end
        end

      fun process-extension(is-first):
        lam(extension):
          cases(A.TableExtendField) extension:
            | s-table-extend-field(_, _, _, _) => extension.value.visit(self)
            | s-table-extend-reducer(shadow l, name, _, col, _) =>
              reducer = reducers.get-value(name)
              acc = accs.get-value(name)
              # Dereferenced accumulator
              acc-id-e = A.s-id-var(acc.id-e.l, acc.id-e.id)
              col-id = find(lam(x): x.name.s == col.s end, columns)
              # Lift from Option monad
              shadow col-id = cases(Option) col-id:
                | none => # Dummy values; will end up unbound
                  # (TODO: Figure out how to make only one 'unbound' error show up
                  # since the desugaring produces the unbound column twice)
                  {id: col,
                    id-b: A.s-bind(l, false, col, A.a-blank),
                    id-e: A.s-id(l, col)}
                | some(v) => v.val
              end
              if is-first:
                A.s-block(A.dummy-loc,
                  [list:
                    A.s-assign(l, acc.id,
                      A.s-app(l, A.s-dot(l, reducer.id-e, "one"), [list: col-id.id-e])),
                    A.s-tuple-get(l, acc-id-e, 1, l)])
              else:
                A.s-block(A.dummy-loc,
                  [list:
                    A.s-assign(l, acc.id,
                      A.s-app(l, A.s-dot(l, reducer.id-e, "reduce"),
                        [list: A.s-tuple-get(l, acc-id-e, 0, l), col-id.id-e])),
                    A.s-tuple-get(l, acc-id-e, 1, l)])
              end
          end
        end
      end

      fun data-pop-mapfun(first):
        A.s-lam(A.dummy-loc, "", empty,  [list: row.id-b], A.a-blank, "",
          A.s-let-expr(A.dummy-loc,
            columns.map(lam(column):
                A.s-let-bind(A.dummy-loc, column.val.id-b,
                  A.s-prim-app(A.dummy-loc, "raw_array_get",
                    [list: row.id-e, column.idx.id-e])) end),
              A.s-prim-app(A.dummy-loc, "raw_array_concat", [list:
                  row.id-e,
                  A.s-array(A.dummy-loc,
                    extensions.map(process-extension(first)))]), true),
          none, none, true)
      end

      A.s-let-expr(A.dummy-loc,
        link(A.s-let-bind(A.dummy-loc, tbl.id-b,
          check-table(column-binds.table.l, column-binds.table.visit(self), lam(t): t end)),
        # Column Index Bindings
        columns.map(lam(column):
          A.s-let-bind(A.dummy-loc, column.idx.id-b,
            get-table-column(l, column-binds.table.l, tbl.id-e, column)) end)),
        # Table Construction
        A.s-block(A.dummy-loc, [list:
          A.s-block(A.dummy-loc, extensions.map(lam(extension):
            check-no-column(l, tbl.id-e, column-binds.l, extension.name, extension.l) end)),
          A.s-prim-app(A.dummy-loc, "makeTable", [list:
            # Header
            A.s-prim-app(A.dummy-loc, "raw_array_concat", [list:
              A.s-dot(A.dummy-loc, tbl.id-e, "_header-raw-array"),
              A.s-array(A.dummy-loc,  extensions.map(lam(e):A.s-str(e.l, e.name) end))]),
            # Data
              with-initialized-reducers(
                A.s-app(l, A.s-id(l, A.s-global("raw-array-map-1")), [list:
                    data-pop-mapfun(true),
                    data-pop-mapfun(false),
                    A.s-dot(A.dummy-loc, tbl.id-e, "_rows-raw-array")]))])]), true)
    end,
    method s-table-update(self, l, column-binds, updates):
      row = mk-id(A.dummy-loc, "row")
      new-row = mk-id(A.dummy-loc, "new-row-row")
      tbl = mk-id(l, "table")

      columns =
        column-binds.binds.map(lam(c):
          {name: A.s-str(A.dummy-loc, c.id.base),
           l:  c.l,
           idx:  mk-id(A.dummy-loc, c.id.base),
           val: {id-b: c,
                 id-e: A.s-id(c.l, c.id)}} end)

      shadow updates =
        updates.map(lam(u):
          {
            name: A.s-str(A.dummy-loc, u.name),
            l:  u.l,
            idx:  mk-id(A.dummy-loc, u.name),
            val:  u.value.visit(self)
          }
        end)

      A.s-let-expr(A.dummy-loc,
        link(A.s-let-bind(A.dummy-loc, tbl.id-b,
          check-table(column-binds.table.l, column-binds.table.visit(self), lam(t): t end)),
        # Column Index Bindings
        columns.map(lam(column):
          A.s-let-bind(A.dummy-loc, column.idx.id-b,
            get-table-column(l, column-binds.table.l, tbl.id-e, column)) end))
        .append(updates.map(lam(update):
            A.s-let-bind(A.dummy-loc, update.idx.id-b,
              get-table-column(l, column-binds.table.l, tbl.id-e, update)) end)),
        # Table Construction
          A.s-prim-app(A.dummy-loc, "makeTable", [list:
            # Header
            A.s-dot(A.dummy-loc, tbl.id-e, "_header-raw-array"),
            # Data
            A.s-app(l, A.s-id(A.dummy-loc, g("raw-array-map")), [list:
              A.s-lam(A.dummy-loc, "", empty,  [list: row.id-b], A.a-blank, "",
                A.s-let-expr(A.dummy-loc,
                  link(
                    A.s-let-bind(A.dummy-loc, new-row.id-b,
                      A.s-prim-app(A.dummy-loc, "raw_array_concat", [list:
                        row.id-e, A.s-array(A.dummy-loc, empty)])),
                    columns.map(lam(column):
                      A.s-let-bind(A.dummy-loc, column.val.id-b,
                        A.s-prim-app(A.dummy-loc, "raw_array_get",
                            [list: new-row.id-e, column.idx.id-e])) end)),
                    A.s-let-expr(A.dummy-loc,
                      updates.map(lam(update):
                        A.s-let-bind(A.dummy-loc, new-row.id-b,
                          A.s-prim-app(A.dummy-loc, "raw_array_set", [list:
                            new-row.id-e, update.idx.id-e, update.val])) end),
                      new-row.id-e, true), true), none, none, true),
              A.s-dot(A.dummy-loc, tbl.id-e, "_rows-raw-array")])]), true)
    end,
    method s-table-select(self, l, columns, table):
      row = mk-id(A.dummy-loc, "row")
      tbl = mk-id(l, "table")
      shadow columns =
        columns.map(lam(c):
          { l: c.l,
            idx:  mk-id(c.l, c.s),
            name: A.s-str(c.l, c.s)} end)
      A.s-let-expr(A.dummy-loc,
        link(A.s-let-bind(A.dummy-loc, tbl.id-b,
          check-table(table.l, table.visit(self), lam(t): t end)),
        # Column Index Bindings
        columns.map(lam(column):
          A.s-let-bind(A.dummy-loc, column.idx.id-b,
            get-table-column(l, table.l, tbl.id-e, column)) end)),
        # Table Construction
        A.s-prim-app(A.dummy-loc, "makeTable", [list:
          # Header
          A.s-array(A.dummy-loc,  columns.map(_.name)),
          # Data
          A.s-app(l, A.s-id(A.dummy-loc, g("raw-array-map")), [list:
            A.s-lam(A.dummy-loc, "", empty,  [list: row.id-b], A.a-blank, "",
              A.s-array(A.dummy-loc,
                columns.map(lam(c):
                  A.s-prim-app(A.dummy-loc, "raw_array_get",
                      [list: row.id-e, c.idx.id-e]) end)), none, none, true),
            A.s-dot(A.dummy-loc, tbl.id-e, "_rows-raw-array")])]), true)
    end,
    method s-table-extract(self, l, column, table):
      tbl = mk-id(table.l, "table")
      col = mk-id(A.dummy-loc, column.s)
      row = mk-id(A.dummy-loc, column.s)
      A.s-let-expr(A.dummy-loc, [list:
        A.s-let-bind(A.dummy-loc, tbl.id-b,
          check-table(table.l, table.visit(self), lam(t): t end)),
        A.s-let-bind(A.dummy-loc, col.id-b,
          get-table-column(l, table.l, tbl.id-e, {l: column.l, name: A.s-str(A.dummy-loc,column.s)}))],
        # Table Construction
        A.s-prim-app(A.dummy-loc, "raw_array_to_list", [list:
          A.s-app(l, A.s-id(A.dummy-loc, g("raw-array-map")), [list:
            A.s-lam(A.dummy-loc, "", empty,  [list: row.id-b], A.a-blank, "",
              A.s-prim-app(A.dummy-loc, "raw_array_get", [list: row.id-e, col.id-e]), none, none, true),
             A.s-dot(A.dummy-loc, tbl.id-e, "_rows-raw-array")])]), true)
    end,
    method s-table-order(self, l, table, ordering):
      ordering-raw-arr = for map(o from ordering):
        A.s-array(o.l, [list: A.s-bool(o.l, o.direction == A.ASCENDING), A.s-str(o.l, o.column.s)])
      end
      A.s-app(l,
        A.s-dot(A.dummy-loc, table.visit(self), "multi-order"),
        [list: A.s-array(A.dummy-loc, ordering-raw-arr)])
    end,
    method s-table-filter(self, l, column-binds, predicate):
      row = mk-id(A.dummy-loc, "row")
      tbl = mk-id(l, "table")
      pred-res = mk-id-ann(predicate.l, "pred", A.a-name(predicate.l, A.s-type-global("Boolean")))

      columns =
        column-binds.binds.map(lam(c):
          {name: A.s-str(A.dummy-loc, c.id.base),
           l:  c.l,
           idx:  mk-id(A.dummy-loc, c.id.base),
           val: {id-b: c,
                 id-e: A.s-id(c.l, c.id)}} end)

      A.s-let-expr(A.dummy-loc,
        link(A.s-let-bind(A.dummy-loc, tbl.id-b,
          check-table(column-binds.table.l, column-binds.table.visit(self), lam(t): t end)),
        # Column Index Bindings
        columns.map(lam(column):
          A.s-let-bind(A.dummy-loc, column.idx.id-b,
            get-table-column(l, column-binds.table.l, tbl.id-e, column)) end)),
        # Table Construction
        A.s-prim-app(A.dummy-loc, "makeTable", [list:
          # Header
          A.s-dot(A.dummy-loc, tbl.id-e, "_header-raw-array"),
          # Data
          A.s-app(l, A.s-id(A.dummy-loc, g("raw-array-filter")), [list:
            A.s-lam(A.dummy-loc, "", empty,  [list: row.id-b], A.a-blank, "",
              A.s-let-expr(A.dummy-loc,
                columns.map(lam(column):
                  A.s-let-bind(A.dummy-loc, column.val.id-b,
                    A.s-prim-app(A.dummy-loc, "raw_array_get",
                          [list: row.id-e, column.idx.id-e])) end),
                    A.s-let-expr(A.dummy-loc,
                      [list: A.s-let-bind(predicate.l, pred-res.id-b, predicate.visit(self))],
                      pred-res.id-e, true), true), none, none, true),
            A.s-dot(A.dummy-loc, tbl.id-e, "_rows-raw-array")])]), true)
    end,
    method s-spy-block(self, l, message, contents):
      ds-message = cases(Option<A.Expr>) message:
        | none => A.s-str(l, "")
        | some(msg) => msg.visit(self)
      end
      ds-contents-list = for map(spy-exp from contents):
        cases(A.SpyField) spy-exp:
          | s-spy-name(l2, name) => {A.s-srcloc(l2, l2); A.s-str(l2, name.id.toname()); name.visit(self)}
          | s-spy-expr(l2, name, value) => {A.s-srcloc(l2, l2); A.s-str(l2, name); value.visit(self)}
        end
      end
      ds-contents = for L.foldr(acc from {empty; empty; empty}, ds-content from ds-contents-list):
        {
          ds-content.{0} ^ link(_, acc.{0});
          ds-content.{1} ^ link(_, acc.{1});
          ds-content.{2} ^ link(_, acc.{2})
        }
      end
      A.s-app(l, A.s-dot(l, A.s-id(l, A.s-global("builtins")), "spy"),
        [list: A.s-srcloc(l, l), ds-message,
          A.s-array(l, ds-contents.{0}), A.s-array(l, ds-contents.{1}), A.s-array(l, ds-contents.{2})])
    end,
  })
end

fun desugar(program :: A.Program):
  doc: ```
        Desugar non-scope and non-check based constructs.
        Preconditions on program:
          - well-formed
          - contains no s-var, s-fun, s-data, s-check, or s-check-test
          - contains no s-provide in headers
          - all where blocks are none
          - contains no s-name (e.g. call resolve-names first)
        Postconditions on program:
          - in addition to preconditions,
            contains no s-for, s-if (will all be s-if-else), s-op, s-method-field,
                        s-cases (will all be s-cases-else), s-not, s-when, s-if-pipe, s-paren
          - contains no s-underscore in expression position (but it may
            appear in binding positions as in s-let-bind, s-letrec-bind)
        ```
  cases(A.Program) program block:
    | s-program(l, _provide, provided-types, imports, body) =>
      generated-binds := SD.make-mutable-string-dict()
      {
        ast: A.s-program(l, _provide, provided-types, imports, desugar-expr(body)),
        new-binds: generated-binds
      }
  end
end

fun mk-id-ann(loc, base, ann) block:
  a = names.make-atom(base)
  generated-binds.set-now(a.key(), C.value-bind(C.bo-local(loc), C.vb-let, a, ann, none))
  { id: a, id-b: A.s-bind(loc, false, a, ann), id-e: A.s-id(loc, a) }
end

fun mk-id-var-ann(loc, base, ann) block:
  a = names.make-atom(base)
  generated-binds.set-now(a.key(), C.value-bind(C.bo-local(loc), C.vb-var, a, ann, none))
  { id: a, id-b: A.s-bind(loc, false, a, ann), id-e: A.s-id-var(loc, a) }
end

fun mk-id(loc, base): mk-id-ann(loc, base, A.a-blank) end

fun mk-id-var(loc, base): mk-id-var-ann(loc, base, A.a-blank) end

check:
  d = A.dummy-loc
  unglobal = A.default-map-visitor.{
    method s-global(self, s): A.s-name(d, s) end,
    method s-atom(self, base, serial): A.s-name(d, base) end
  }
  p = lam(str): PP.surface-parse(str, "test").block.visit(A.dummy-loc-visitor) end
  ds = lam(prog): desugar-expr(DNew.desugar-expr(prog)).visit(unglobal).visit(A.dummy-loc-visitor) end
  id = lam(s): A.s-id(d, A.s-name(d, s)) end
  one = A.s-num(d, 1)
  two = A.s-num(d, 2)
  pretty = lam(prog): prog.tosource().pretty(80).join-str("\n") end

  if-else = "if true: 5 else: 6 end"
  ask-otherwise = "ask: | true then: 5 | otherwise: 6 end"
  p(if-else) ^ pretty is if-else
  p(ask-otherwise) ^ pretty is ask-otherwise

  prog2 = p("[list: 1,2,1 + 2]")
  ds(prog2)
    is A.s-block(d,
    [list:  A.s-app(d,
        A.s-prim-app(d, "getMaker3", [list: A.s-id(d, A.s-name(d, "list")), A.s-str(d, "make3"), A.s-srcloc(d, d), A.s-srcloc(d, d)]),
        [list:  one, two, A.s-app(d, id("_plus"), [list: one, two])])])

  prog3 = p("[list: 1,2,1 + 2,1,2,2 + 1]")
  ds(prog3)
    is A.s-block(d,
    [list:  A.s-app(d,
        A.s-prim-app(d, "getMaker", [list: A.s-id(d, A.s-name(d, "list")), A.s-str(d, "make"), A.s-srcloc(d, d), A.s-srcloc(d, d)]),
        [list:  A.s-array(d,
            [list: one, two, A.s-app(d, id("_plus"), [list: one, two]),
              one, two, A.s-app(d, id("_plus"), [list: two, one])])])])

  prog4 = p("for map(elt from l): elt + 1 end")
  ds(prog4) is p("map(lam(elt): _plus(elt, 1) end, l)")

  # Some kind of bizarre parse error here
  # prog4 = p("(((5 + 1)) == 6) or o^f")
  #  ds(prog4) is p("builtins.equiv(5._plus(1), 6)._or(lam(): f(o) end)")

  # ds(p("(5)")) is ds(p("5"))

  # prog5 = p("cases(List) l: | empty => 5 + 4 | link(f, r) => 10 end")
  # dsed5 = ds(prog5)
  # cases-name = tostring(dsed5.stmts.first.binds.first.b.id)
  # compare = (cases-name + " = l " +
  #   cases-name + "._match({empty: lam(): 5._plus(4) end, link: lam(f, r): 10 end},
  #   lam(): raise('no cases matched') end)")
  # dsed5 is ds(p(compare))

end
